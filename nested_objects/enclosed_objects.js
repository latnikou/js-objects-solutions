// значением свойства объекта может быть всё, что угодно, включая другой объект или массив

const user = {
    name: 'Maxim',
    married: true, 
    age: 21,
};

// добавим новое свойство 
user.children = [
    { name: 'Mila', age: 1 },
    { name: 'Petr', age: 10 },
  ];

// когда мы обращаемся ко вложенным элементам, мы это делаем по цепочке 

console.log(user.children[0].name);

// console.log() не выводит объекты глубже второго уровня вложенности на экран, он просто вместо объектов пишет [Object]
// для этого есть JSON.stringify(obj)

const obj = { a: { b: { c: { key: 'value' }, e: [1, 2] } } };
console.log(obj);
// { a: { b: { c: [Object], e: [Array] } } }

/* как проверять в глубину? если есть 4х уровня вложенности, нам надо будет проверить все четыре, чтобы понять, что свойство реально существует */

// чтобы извлечь данные, а не просто проверить, существуют ли они, есть оператор опциональной последовательности 

obj = {};

obj?.one?.two?.three // undefined

/* никогда не приводит к ошибке, работает на любых типах данных и всегда возвращает либо undefined, либо значение указанного свойства, если оно существует  */

// оператор нулевого слияния 

obj = {};
obj?.one?.two?.three ?? 'я встану тут';

// если слева - null или undefined - встанет дефолтное значение

// работает не как "или", меняет значение, если там undefined или null

const value = false;

value ?? 'default'; // false
value || 'default'; // default

/* как обычно на помощь приходит lodash */

import _ from "lodash";

obj = {};

value = _.get(obj, 'one.two.three', 'defaultVAlue');
console.log(value);

// работает так же как ??, но можно передать аргументом массив ключей, например

